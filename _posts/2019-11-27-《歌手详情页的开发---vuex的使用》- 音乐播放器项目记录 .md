---
layout:     post   				    # 使用的布局（不需要改）
title:      音乐播放器项目记录 				# 标题 
subtitle:   《歌手详情页的开发---vuex的使用》 #副标题
date:       2019-11-27 				# 时间
author:     Charlene 						# 作者
header-img: img/js1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 音乐播放器项目记录
---
#### 1. 歌手详情页子路由配置
singer-detail组建的开发：创建并编写简单的页面<br>

在index.js中重新配置路由，点击歌手就可以转到详情列表了<br>
```
{
  path: '/singer',
  component: Singer,
  children: [
    {
      path: ':id',
      component: SingerDetail
    }
  ]
}
```
配置好子路由之后，要有一个routerview去承载这个子路由，我们回到singer组件，在list-view（歌手列表组件）的下边挂载子router-view<br>
```
<template>
  <div class="singer">
    <!-- 将singers数据命名为data变量传递给listview.vue组件 -->
    <list-view @select="selectSinger" :data="singers"></list-view>
    <!-- 承载子路由SingerDetail -->
    <router-view></router-view>
  </div>
</template>
```
添加路由跳转逻辑，我们希望我们点击歌手列表的时候，可以进行路由跳转，歌手列表基于list-view实现，所以在listview组件中，添加一个点击事件selectItem();<br>
```
<ul>
  <!-- 这里面的每一个li代表每个组别里面的每一位歌手 -->
  <li @click="selectItem(item)" v-for="(item, index) in group.items" :key="index" class="list-group-item">
    <img class="avatar" v-lazy="item.avatar">
    <span class="name">{{item.name}}</span>
  </li>
</ul>
```
在listview中添加点击事件并将item派发出去，点击事件没有业务逻辑，仅仅是将数据传出去<br>
```
selectItem(item) {
  this.$emit('select', item) // 将点击的是哪一位歌手派发出去
},
```
回到singer.vue界面监听函数<br>
```
<!-- 将singers数据命名为data变量传递给listview.vue组件 -->
<list-view @select="selectSinger" :data="singers"></list-view>
```
methods中实现监听函数
```
 selectSinger(singer) {
        this.$router.push({
          path: `/singer/${singer.id}`  // // router的编程式跳转接口
        })
       // this.setSinger(singer)
       console.log(`${singer.id}`)
      },
```
点击歌手出现歌手详情，但是界面的跳转略显生硬，我们为singer-detail的跳转增加一个transition动画
```
<template>
  <transition name="slide">
      <music-list :songs="songs" :title="title" :bg-image="bgImage"></music-list>
  </transition>
</template>
```
```
.slide-enter-active, .slide-leave-active
    transition all 0.3s
.slide-enter, .slide-leave-to
    transform translate3d(100%, 0, 0)
```
#### 2. Vuex 初始化及歌手数据的配置<br>
当我们点击歌手列表切换到歌手详情页的时候，需要把歌手的数据，歌手的名称，图片等，通过参数的传递也是可以解决的，利用vuex解决这个问题也可。<br>

State：所有组件的所有状态和数据，放在同一的内存空间来管理。<br>
Action：当组件中的数据发生变化的时候，Component可以通过dispatch一个action，action会做一些异步操作。<br>
Mutation：Action commit到mutation，他是唯一一个可以修改state的途径，其他任何方式修改state都是非法的。<br>

使用场景：解决多个组件之间的状态共享，这些组件可能是一些关联度很低的组件，所以我们想要共享数据就比较困难。比如遇到一些路由跳转场景，如果我们传递的参数很复杂的话，vuex是很好的选择<br>

index: vuex的入口函数src->store->index.js，<br>
state: 状态管理：src->store->state.js，<br>
mutation建立mutations.js，<br>
mutation-types: 与mutation相关的mutation名字的文件叫mutation-types，存储于mutation相关的字符串常亮，<br>
actions：异步修改，或者对mutation做一些封装，<br>
getters: 对state数据进行映射，<br>

首先，定义state.js
```
const state = {
    singer: {},
    playing: false // 播放状态
}
 
export default state
```
mutation-type:定义常量
```
// 定义mutation的常量
export const SET_SINGER = 'SET_SINGER'
```
然后在mutations.js中定义修改的操作：
```
import * as types from './mutation-types'
 
const mutations = { // mutation相关的修改方法
    [types.SET_SINGER](state, singer) { // 当前状态树的state，提交mutation时传的payload
        state.singer = singer
    }
}
```
有了mutation修改数据，我们怎么映射到state中去呢，通常从getters中取state数据到vue components中
```
export const singer = state => state.singer // 使用getter取到组件里的数据
```
action.js暂时不用初始化，因为还没有相关action的修改

接下来将入口js，即index.js进行初始化
```
import Vue from 'vue'
import Vuex from 'vuex'
import * as actions from './actions'
import * as getters from './getters'
import state from './state'
import mutations from './mutations'
import createLogger from 'vuex/dist/logger'
 
Vue.use(Vuex) // 注册插件
 
// 调试工具
const debug = process.env.NODE_ENV !== 'production'
 
export default new Vuex.Store({ // 我们要去export store的一个实例，单例模式
    actions,
    getters,
    state,
    mutations,
    strict: debug, // 检测state的修改是不是来源于mutation
    plugins: debug ? [createLogger()] : [] // 通过mutation修改state的时候会在控制台打印logger
})
```
在main.js中修改，将store注入到vue中，此时，vuex的初始化配置完成
```
import store from './store'
new Vue({
  el: '#app',
  router,
  store,
  render: h => h(App)
})
```
回到singer.vue界面：当singer.vue组件进行跳转的时候，我没去去set这个singer，我们把这个singer当成vuex的一个数据
```
import {mapMutations} from 'vuex'
```
mapMutation是对mutation进行了一层封装，我们import Mapmutation之后，我们只要在methods函数的最后，通过扩展运算符的方式调用mapMutations,去做一个对象的映射，将mutation的修改映射成一个方法名，setSinger，他实际上就是mutation-types中的SET_SINGER常量
```
...mapMutations({
   setSinger: 'SET_SINGER'
 })
```
之后再代码中，我们就可以调用setSinger方法往state中写数据了
```
    selectSinger(singer) {
        this.$router.push({ // router的编程式跳转接口
          path: `/singer/${singer.id}`
        })
        // 在setSinger中将数据（singer）传进来
        // 实现了对一个mutation的提交，修改了state，实际上执行了mutations.js中的types.SER_SINGER函数
        // state.singer = singer,实现了对state的修改，这里是往state中写了singer数据
        this.setSinger(singer) 
       // console.log(`${singer.id}`)
      }
```
将singer数据提交到state之后，然后在详情界面singer-detail.vue中去获取数据
```
import {mapGetters} from 'vuex' // vuex为取出数据提供的语法糖
```
在computed中执行mapGetters函数
```
computed: { // getter映射的就是computed
    ...mapGetters([
// export const singer = state => state.singer // 使用getter取到组件里的数据
      'singer' // 对应到store中的getters定义的singer
    ])
}
```
做了这一层映射以后，我们就相当于在vue实例中挂载了一个叫singer的属性，然后我们就可以拿到singer，在created的时候进行consloe.log()进行测试
```
created() {
   console.log(this.singer) // 测试输出singer数据
}
```
![测试输出singer数据](https://raw.githubusercontent.com/Charlene12345/img-repo/master/singer.png)


