---
layout:     post   				    # 使用的布局（不需要改）
title:      音乐播放器项目记录 				# 标题 
subtitle:   《歌手详情页的开发---vuex的使用》 #副标题
date:       2019-11-27 				# 时间
author:     Charlene 						# 作者
header-img: img/js1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 音乐播放器项目记录
---
#### 1. 歌手详情页子路由配置
singer-detail组建的开发：创建并编写简单的页面<br>

在index.js中重新配置路由，点击歌手就可以转到详情列表了<br>
```
{
  path: '/singer',
  component: Singer,
  children: [
    {
      path: ':id',
      component: SingerDetail
    }
  ]
}
```
配置好子路由之后，要有一个routerview去承载这个子路由，我们回到singer组件，在list-view（歌手列表组件）的下边挂载子router-view<br>
```
<template>
  <div class="singer">
    <!-- 将singers数据命名为data变量传递给listview.vue组件 -->
    <list-view @select="selectSinger" :data="singers"></list-view>
    <!-- 承载子路由SingerDetail -->
    <router-view></router-view>
  </div>
</template>
```
添加路由跳转逻辑，我们希望我们点击歌手列表的时候，可以进行路由跳转，歌手列表基于list-view实现，所以在listview组件中，添加一个点击事件selectItem();<br>
```
<ul>
  <!-- 这里面的每一个li代表每个组别里面的每一位歌手 -->
  <li @click="selectItem(item)" v-for="(item, index) in group.items" :key="index" class="list-group-item">
    <img class="avatar" v-lazy="item.avatar">
    <span class="name">{{item.name}}</span>
  </li>
</ul>
```
在listview中添加点击事件并将item派发出去，点击事件没有业务逻辑，仅仅是将数据传出去<br>
```
selectItem(item) {
  this.$emit('select', item) // 将点击的是哪一位歌手派发出去
},
```
回到singer.vue界面监听函数<br>
```
<!-- 将singers数据命名为data变量传递给listview.vue组件 -->
<list-view @select="selectSinger" :data="singers"></list-view>
```
methods中实现监听函数
```
 selectSinger(singer) {
        this.$router.push({
          path: `/singer/${singer.id}`  // // router的编程式跳转接口
        })
       // this.setSinger(singer)
       console.log(`${singer.id}`)
      },
```
点击歌手出现歌手详情，但是界面的跳转略显生硬，我们为singer-detail的跳转增加一个transition动画
```
<template>
  <transition name="slide">
      <music-list :songs="songs" :title="title" :bg-image="bgImage"></music-list>
  </transition>
</template>
```
```
.slide-enter-active, .slide-leave-active
    transition all 0.3s
.slide-enter, .slide-leave-to
    transform translate3d(100%, 0, 0)
```
#### 2. Vuex 初始化及歌手数据的配置<br>
当我们点击歌手列表切换到歌手详情页的时候，需要把歌手的数据，歌手的名称，图片等，通过参数的传递也是可以解决的，利用vuex解决这个问题也可。<br>

State：所有组件的所有状态和数据，放在同一的内存空间来管理。<br>
Action：当组件中的数据发生变化的时候，Component可以通过dispatch一个action，action会做一些异步操作。<br>
Mutation：Action commit到mutation，他是唯一一个可以修改state的途径，其他任何方式修改state都是非法的。<br>

使用场景：解决多个组件之间的状态共享，这些组件可能是一些关联度很低的组件，所以我们想要共享数据就比较困难。比如遇到一些路由跳转场景，如果我们传递的参数很复杂的话，vuex是很好的选择<br>

index: vuex的入口函数src->store->index.js，<br>
state: 状态管理：src->store->state.js，<br>
mutation建立mutations.js，<br>
mutation-types: 与mutation相关的mutation名字的文件叫mutation-types，存储于mutation相关的字符串常亮，<br>
actions：异步修改，或者对mutation做一些封装，<br>
getters: 对state数据进行映射，<br>

首先，定义state.js
```
const state = {
    singer: {},
    playing: false // 播放状态
}
 
export default state
```
mutation-type:定义常量
```
// 定义mutation的常量
export const SET_SINGER = 'SET_SINGER'
```
然后在mutations.js中定义修改的操作：
```
import * as types from './mutation-types'
 
const mutations = { // mutation相关的修改方法
    [types.SET_SINGER](state, singer) { // 当前状态树的state，提交mutation时传的payload
        state.singer = singer
    }
}
```
有了mutation修改数据，我们怎么映射到state中去呢，通常从getters中取state数据到vue components中
```
export const singer = state => state.singer // 使用getter取到组件里的数据
```
action.js暂时不用初始化，因为还没有相关action的修改

接下来将入口js，即index.js进行初始化
```
import Vue from 'vue'
import Vuex from 'vuex'
import * as actions from './actions'
import * as getters from './getters'
import state from './state'
import mutations from './mutations'
import createLogger from 'vuex/dist/logger'
 
Vue.use(Vuex) // 注册插件
 
// 调试工具
const debug = process.env.NODE_ENV !== 'production'
 
export default new Vuex.Store({ // 我们要去export store的一个实例，单例模式
    actions,
    getters,
    state,
    mutations,
    strict: debug, // 检测state的修改是不是来源于mutation
    plugins: debug ? [createLogger()] : [] // 通过mutation修改state的时候会在控制台打印logger
})
```
在main.js中修改，将store注入到vue中，此时，vuex的初始化配置完成
```
import store from './store'
new Vue({
  el: '#app',
  router,
  store,
  render: h => h(App)
})
```
回到singer.vue界面：当singer.vue组件进行跳转的时候，我没去去set这个singer，我们把这个singer当成vuex的一个数据
```
import {mapMutations} from 'vuex'
```
mapMutation是对mutation进行了一层封装，我们import Mapmutation之后，我们只要在methods函数的最后，通过扩展运算符的方式调用mapMutations,去做一个对象的映射，将mutation的修改映射成一个方法名，setSinger，他实际上就是mutation-types中的SET_SINGER常量
```
...mapMutations({
   setSinger: 'SET_SINGER'
 })
```
之后再代码中，我们就可以调用setSinger方法往state中写数据了
```
    selectSinger(singer) {
        this.$router.push({ // router的编程式跳转接口
          path: `/singer/${singer.id}`
        })
        // 在setSinger中将数据（singer）传进来
        // 实现了对一个mutation的提交，修改了state，实际上执行了mutations.js中的types.SER_SINGER函数
        // state.singer = singer,实现了对state的修改，这里是往state中写了singer数据
        this.setSinger(singer) 
       // console.log(`${singer.id}`)
      }
```
将singer数据提交到state之后，然后在详情界面singer-detail.vue中去获取数据
```
import {mapGetters} from 'vuex' // vuex为取出数据提供的语法糖
```
在computed中执行mapGetters函数
```
computed: { // getter映射的就是computed
    ...mapGetters([
// export const singer = state => state.singer // 使用getter取到组件里的数据
      'singer' // 对应到store中的getters定义的singer
    ])
}
```
做了这一层映射以后，我们就相当于在vue实例中挂载了一个叫singer的属性，然后我们就可以拿到singer，在created的时候进行consloe.log()进行测试
```
created() {
   console.log(this.singer) // 测试输出singer数据
}
```
![测试输出singer数据](https://raw.githubusercontent.com/Charlene12345/img-repo/master/singer.png)

#### 歌手详情数据抓取
[歌手详情接口来源](https://juejin.im/post/5a35228e51882506a463b172#heading-7)

singermid不同，歌手详情数据就不同，其他的都一样
```
// src->api>singer.js
// 歌手详情数据抓取
export function getSingerDetail(singerId) {
  const url = 'https://c.y.qq.com/v8/fcg-bin/fcg_v8_singer_track_cp.fcg'

  const data = Object.assign({}, commonParams, {
    loginUin: 0,
    hostUin: 0,
    // format: 'jsonp',
    inCharset: 'utf8',
    notice: 0,
    platform: 'yqq',
    needNewCode: 0,
    singermid: singerId,
    order: 'listen',
    begin: 0,
    num: 100,
    songstatus: 1
  })

  return jsonp(url, data, options)
}
```
回到src->common->singer-detail.vue中，在created中定义获取数据的方法
```
import {getSingerDetail} from 'api/singer'
import {ERR_OK} from 'api/config'
    created() {
      //  console.log(this.singer) // 测试输出singer数据
      // 调用方法获取数据
      this._getDetail()
    }
```
在_getDetail()中调用刚才的api方法getSingerDetail，之前我们已经通过...mapGetter()获取到了singer，这里讲singer的id传入getSingerDetail函数；找不到歌手id的时候，刷新会退回到singer路由
```
_getDetail() {
  // 用户在歌手详情页面上刷新  则回退到上一页面
  if (!this.singer.id) {
    this.$router.push('/singer')
    return
  }
  // 因为我们已经获取到了singer数据，此处可以通过this.singer直接调用获取歌手的id
  getSingerDetail(this.singer.id).then((res) => {
    if (res.code === ERR_OK) {
      // console.log(res.data.list)
      this.songs = this._normalizeSongs(res.data.list)
      // console.log(this.songs)
    }
  })
},
```
![console.log(res.data.list)](https://raw.githubusercontent.com/Charlene12345/img-repo/master/res-data-list.png)

#### 歌手详情数据处理和Song类的封装

_normalizeSongs函数是对歌手数据进行格式化处理：跟之前的singer类中进行new singer处理相同，在这里，我们创建一个song类，对song的相关属性进行封装。参数很多的场景就可以设计成类，没有设计成对象，是因为类的扩展性要比对象好很多。<br>
创建common->js->song.js，类似于singer的id,name,avatar
```
// 我们需要在 _getSingerList 获取到的数据里面去提取我们需要的部分，来构造成我们需要的数据对象
export default class Song {
  constructor({id, mid, singer, name, album, duration, image, url}) {
    this.id = id
    this.mid = mid
    this.name = name
    this.album = album
    this.duration = duration
    this.image = image
    this.url = url
    this.singer = singer
  }
```
在singerDetail里面我们去维护一个data，return一个song
```
data() {
  return {
    songs: []
  }
},
```
singer.js 获取vkey
```
export function getVkey(songmid) {
  const url = 'https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg'
  const data = Object.assign({}, {
    loginUin: 0,
    hostUin: 0,
    platform: 'yqq',
    uin: 0,
    needNewCode: 0,
    cid: 205361747,
    songmid: songmid,
    filename: `C400${songmid}.m4a`,
    guid: 5544337966
  })
  return jsonp(url, data)
}
```
createSong(musicData, vkey)) // 将获取到的musicData源数据转化为我们定义好的song类，直接new的方式代码量较多，编写一个工厂方法代替，所以在js->song.js中
```
export function createSong(musicData, vkey) {
  return new Song({
    id: musicData.songid,
    mid: musicData.songmid,
    singer: filterSinger(musicData.singer), // 处理一首歌有两个歌手的情况
    name: musicData.songname,
    album: musicData.albumname,
    duration: musicData.interval, // 歌曲的时长
    image: `https://y.gtimg.cn/music/photo_new/T002R300x300M000${musicData.albummid}.jpg?max_age=2592000`,
    url: `http://aqqmusic.tc.qq.com/amobile.music.tc.qq.com/C400${musicData.songmid}.m4a?vkey=${vkey}&guid=5544337966&uin=0&fromtag=38`
  })
}
```
singer-detail中，在_normalizeSongs中对歌手详情list数据做一个规范化处理
```
_normalizeSongs(list) {
  let ret = []
  list.forEach((item) => {
    let {musicData} = item // 对象解构赋值，只取musicData数据
    getVkey(musicData.songmid).then((res) => {
      const vkey = res.data.items[0].vkey
      if (musicData.songid && musicData.albumid) {
        ret.push(createSong(musicData, vkey))
      }
    })
  })
  return ret
}
```



















————————————————
版权声明：本文为CSDN博主「qq_22317389」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_22317389/article/details/81226315

